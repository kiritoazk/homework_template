# 20201050311实验报告

## 学号：20201050311 

>注:为保护同学隐私，请不要填写姓名
 
## 实验目的：实验 2.1 动态规划算法的实现与时间复杂度测试
编程实现经典的动态规划算法，理解动态规划算法设计的基本思想、程序实
现的相关技巧，加深对动态规划算法设计与分析思想的理解。通过程序的执行时
间测试结果，与理论上的时间复杂度结论进行对比、分析和验证。

## 实验原理

动态规划算法的基本思想
（1） 动态规划是一种在数学和计算机科学中使用的、用于求解包含重叠子问题的
最优化问题的有效方法。其基本思想是：将原问题分解为相似的子问题，在求解
的过程中通过子问题的解描述并求出原问题的解。动态规划的思想是多种算法的
基础，被广泛应用于计算机科学和工程领域，在查找有很多重叠子问题的情况的
最优解时有效。它将问题重新组合成子问题，为了避免多次解决这些子问题，它
们的结果都逐渐被计算并保存，从小规模的子问题直到整个问题都被解决。因此，
动态规划对每一子问题只做一次计算，具有较高的效率。

 分治算法与动态规划算法的对比：针对子问题是否重叠
（2）虽然很多问题均可分解为子问题、动态规划和分治算法都是通过子问题的解
决来获得原问题的解。然而，分治算法适用于子问题不重叠（即相互独立）的情
形，对于子问题重叠的情形分治法具有较高的时间复杂度，动态规划是针对这类
情形的有效算法。

## 实验输入数据集


文本数据集：背包容量 100 物品数量 10

文件数据集：[数据集](https://github.com/kiritoazk/homework_template/blob/main/data/list2.txt)

## 实验内容

1. [test_2](/test_2/KnapsackDP.c) 0-1背包问题
2. [test_2](/test_2/feibonaqieDAC.c)  动态规划算法的自适应测试
3. [test_2](/test_2/feibonaqieDP.c)  动态规划算法的自适应测试


## 实验预期结果与实际结果
实验预期结果：
我们输入背包的容量100，物品的数量10，程序开始运行随机生成物品的重量以及
价值并且开始装入背包，结果会输出装入背包的过程以及被标记的装入背包的物品
并且会记录装入背包的最大价值以及程序运行的总时间


## 实验结果
![image](https://raw.githubusercontent.com/kiritoazk/homework_template/main/test_2/img/capture_20220613192155142.bmp)

## 实验要求

(1) 编程实现以上算法，并进行测试，保证程序正确无误。其中，分别在程
序开始和结束处设置记录系统当前时间的变量、用于计算程序执行的时间（以毫
秒(ms)作为程序执行时间的计数单位）。

(2) 测试 C 值不变的情形下随着 n 增加、程序执行时间增加的趋势。对于
C=200、400、800、2000 这四种情形，分别使用 1.1 节中的随机数生成算法生成
n 个随机数作为 n 个物品的重量，再生成 n 个随机数作为 n 个物品的价值（n=10, 
20, 40, 100, 200, 400, 800, 2000）。对于每个 C 值，记录随着 n 增加程序的执行时
间，并使用 MS Excel、Matlab 或 Origin 等图表绘制工具生成各不同 C 值情形下
程序执行时间的对比曲线图（4 条折线）。

## 实验结果
![image](https://github.com/kiritoazk/homework_template/blob/main/test_2/img/capture_20220613192932359.bmp)


## 实验目的 2.实验 2.2 动态规划算法的适应性测试 
对于同一问题，编程实现其分治算法和动态规划算法，通过对比分析，理解
动态规划算法的适用情形。通过程序的执行时间测试结果，与理论结论进行对比、
分析和验证。

## 实验原理
分治算法与动态规划算法的对比：针对子问题是否重叠
虽然很多问题均可分解为子问题、动态规划和分治算法都是通过子问题的解
决来获得原问题的解。然而，分治算法适用于子问题不重叠（即相互独立）的情
形，对于子问题重叠的情形分治法具有较高的时间复杂度，动态规划是针对这类
情形的有效算法。

## 实验要求

(1) “加法”是以上两个斐波纳契数算法的基本操作。编程实现以上 DAC_f
和 DP_f 算法，并进行测试，在其中设置加法执行次数的计数器变量。

(2) 分别测试不同 n 值（n=5, 10, 15, 20, 25, 30）情形下 DAC_f 和 DP_f 算法
的加法次数，记录加法次数，并使用 MS Excel、Matlab 或 Origin 等图表绘制工
具生成各不同 n 值情形下以上两个算法加法次数的对比曲线图（2 条折线）。

(3) 与两个算法时间复杂度的理论结论进行对比分析，总结分治与动态规划
算法的适用条件和特点，完成实验报告
 
 ## 实验结果
 ![imag]()
 ## 实验总结
对于不同输入的N的值，相比之下动态规划的比较次数远低于分治算法。动态规划也是一
种分治思想（比如其状态转移方程就是一种分治），但与分治算法不同的是，分治算法是
把原问题分解为若干个子问题，自顶向下求解子问题，合并子问题的解，从而得到原问题
的解。 动态规划也是把原始问题分解为若干个子问题，然后自底向上，先求解最小的子
问题，把结果存在表格中，在求解大的子问题时，直接从表格中查询小的子问题的解，
避免重复计算，从而提高算法效率。 是指问题的最优解包含其子问题的最优解。 最有
子结构是使用动态规划的最基本的条件，如果不具有最优子结构性质，就不可以使用动
态规划解决。 证明的例子 子问题重叠不是使用动态规划的必要条件，但是问题存在子
问题重叠的特性更能够充分彰显动态规划的优势。
