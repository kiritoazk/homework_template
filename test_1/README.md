# 20201050311实验报告

## 学号：20201050311 

>注:为保护同学隐私，请不要填写姓名
 
## 实验目的：

1.实验一、分治算法 
通过排序算法的程序实现和执行时间测试，与理论上的结论进行对比分析，
深入理解算法时间复杂度渐进性态和和增长率的概念；理解分治算法设计的基本
思想、递归程序实现的基本方法，加深对分治算法设计与分析思想的理解。

## 实验原理
算法时间复杂度分析的相关概念
（1） 算法的计算时间取决于算法中某些操作的执行次数，这些操作是算法时
间复杂度分析的依据。增长率反映了算法的计算时间复杂度，即随着算法输入规
模的增加、算法计算时间增加的趋势。算法的计算时间复杂度针对输入数据的等
价类来分析或测试。
 随机数生成算法
（2）通过程序生成（伪）随机数，作为实验用测试数据。可使用编程语言自带的
random 函数生成，也可以采用一些有效的随机数生成算法生成，例如“线性同
余法”，基于该算法，只要参数选择合适，所产生的伪随机数就能满足均匀性和
独立性，与真正的随机数具有相近的性质。该算法的基本思想如下：
通过设置 Xi+1=(aXi+c) mod m, n>0，其中的 4 个整数参数：
m为模数, m>0；
a为乘数, 0<a<m；
c为增量, 0<c<m；
X[0]为开始值, 0<X[0]<m。
这样得到所求的随机数序列{Xi}，称作线形同余序列。

## 实验输入数据集


文本数据集：5,3,4,6,5 
文件数据集：[数据集](./data/list.txt)

## 实验内容

1. [test_1](/test_1/BubbleSort.c) 冒泡算法实现的版本
2. [test_1](/test_1/MergeSort.c)  归并算法实现的版本
3. [test_1](/test_1/QuickSort.c)  快速排序算法实现的版本

## 实验预期结果与实际结果
实验预期结果：输入随机生成数的个数之后，我们接着输入4个参数的值，会给出三个排序算排序之后的数组以及其分别的排序次数

## 冒泡排序的结果如图
![image](https://raw.githubusercontent.com/kiritoazk/homework_template/main/test_1/img/capture_20220612203857020.bmp)

## 归并排序算法的结果如图
![image](https://raw.githubusercontent.com/kiritoazk/homework_template/main/test_1/img/capture_20220612203923400.bmp)

## 快速排序之后的结果如图
![image](https://github.com/kiritoazk/homework_template/blob/main/test_1/img/capture_20220612203941911.bmp)

## 算法计算时间复杂度的概念
(1) 使用随机数生成方法生成包含 100 个随机数的测试数据，记录这些数据，
并分别记录以上三个排序算法比较操作的执行次数；再重新生成包含 100 个随机
数的测试数据，记录这些数据三个排序算法比较操作的执行次数。
对比两次生成的测试数据和算法执行中比较操作的次数，理解算法复杂度分
析时输入数据等价类的含义。

(2) 使用随机数生成方法生成不同规模的测试数据（10 个，100 个，1000 个，
2000 个，5000 个，10000 个，100000 个，……），对于每种规模的测试数据，分
别记录 BubbleSort、MergeSort 和 QuickSort 算法执行中比较操作的执行次数，使
7用 MS Excel、Matlab 或 Origin 等图表绘制工具生成随着输入数据增加、以上三
个算法比较操作次数增加的对比曲线图（折线）。基于生成的曲线图，与时间复
杂度的理论结论对比分析，理解计算时间渐进性态和增长率的概念。

(3) 在 MergeSort 和 QuickSort 算法中设置比较操作执行的全局计数器，编程
实现算法（输出最终的计数值）；设置记录每次递归调用时描述问题规模的变量，
程序结束时输出其值；通过测试保证程序正确无误，注意递归程序的实现、调试
和测试。使用（3）中生成的测试数据（10 个，100 个，1000 个，2000 个，5000
个，10000 个，100000 个，……），对于每种规模的测试数据，分别记录以上两
个算法执行中各子问题的规模，并用表格方式记录所有情形各子问题的规模值。

```bash
答：通过输入100个数据之后
冒泡排序：4950
归并排序：672
快速排序：4950
我们可以看出快速排序和冒泡排序的算法比较次数一样，输入数据等价类的含义是具有相同性质的输入数据使得快速排序的比较次数和冒泡排序一样，使得快速排序是总处于最坏的情况，时间复杂度为O(n^2)
```
## 增长折线图
![imag](https://github.com/kiritoazk/homework_template/blob/main/test_1/img/capture_20220612210947377.bmp)
